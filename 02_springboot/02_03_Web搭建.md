

Spring Boot将传统Web开发的mvc、json、tomcats等框架整合，提供了 spring-boot-starter--web组件，简化了Web应用配置。
创建Spring BootI项目勾选Spring Web选项后，会自动将spring-boot-starter-web组件加入到项目中。
spring-boot-starter-web启动器主要包括web、webmvc、json、tomcat等 基础依赖组件，作用是提供Wb开发场景所需的所有底层依赖。
webmvc为Web开发的基础框架，json为JSON数据解析组件，tomcat为自带 的容器依赖。


```
<dependency>
    <groupld.org.springframework.boot</groupld>
    <artifactld>spring-boot-starter-web</artifactld>
</dependency>
```


# 1 Controller 

- SpringBoot 提供了 @Controller 和 @ResrController 两种注解来标识此类负责接受和处理HTTP请求 
- 如果请求的是页面和数据, 使用@Controller注解就可以, 如果知识请求数据 , 则可以使用@RestController 


![](images/Pasted%20image%2020250220165611.png)

```java
@Controller
public class HelloControIIer {
    @RequestMapping "/hetto")
    public String index(ModelMap map){
        map.addAttribute("name" , "zhangsan");
        return "hello";  // 因为用的是 controller 所以应该是 返回一个 view , 回去找 一个hello.html 的 页面 
);
```


@RestController 会将返回对象转为 json 格式 
![](images/Pasted%20image%2020250220170309.png)


# 2 路由映射  @RequestMapping

- @RequestMapping注解主要负责URL的路由映射。它可以添加在Controller 类或者具体的方法上。
- 如果添加在Controller类上，则这个Controller中的所有路由映射都将会加上此 映射规则，如果添加在方法上，则只对当前方法生效。
- @RequestMappingi注解包含很多属性参数来定义HTTP的请求映射规侧。常用的属性参数如下：
- value:请求URL的路径，支持URL模板、正则表达式
- method:HTTP请求方法
- consumes::请求的媒体类型(Content-Type),如application/.json
- produces:响应的媒体类型
- params,headers::请求的参数及请求头的值

## 2.1 @RequestMapping 中的参数 

路径匹配 
- @RequestMapping的value属性用于匹配URL映射，value支持简单表达式 @RequestMapping("/user")
- @RequestMapping支持使用通配符匹配URL,用于统一映射某些URL规侧类似的请求：`@RequestMapping("/getJson/*json")`,当在浏览器中请求 /getJson/a,json或者/getJson,/b.json时都会匹配到后台的son方法
- @RequestMapping的通配符匹配非常简单实用，支持 `?` 等通配符
- 符号 `*` 匹配任意字符，符号 `**`  匹配任意路径 (就是代表多级 可以任意加斜杠 )，符号 `?` 匹配单个字符。 
- 有通配符的优先级低于没有通配符的，比如`/user/add,json`比`user/*json`优先 匹配。 有  `**` 通配符的优先级低于有  `*` 通配符的。

@RequestMapping(value ="/getData")
public String getData(){
    return "hello";
}

## 2.2 HTTP Method 请求匹配 
- HTTP请求Method有GET、POST、PUT、DELETE等方式。HTTP支持的全部 Method
- @RequestMapping:注解提供了method参数指定请求的Method类型，包括 RequestMethod.GET、RequestMethod.POST、RequestMethod.DELETE、 RequestMethod.PUT等值，分别对应HTTP请求的Method

```java
@RequestMapping(value ="/getData",method RequestMethod.GET)
public String getData(){
    return "hello";
}
```

- Method匹配也可以使用@GetMapping、@PostMapping等注解代替。


## 2.3 参数传递

@RequestParam将请求参数绑定到控制器的方法参数上，接收的参数来自 HTTP请求体或请求url的QueryString,当请求的参数名称与Controller的业务 方法参数名称一致时，@RequestParam可以省略

```java
@RequestMapping(value = "/getTest3", method = RequestMethod.GET)
//http://localhost:8080/getTest3?nickname=yzh
// If required = false, the parameter nickname is optional
// nickname is mapped to name, so the value of name is yzh. in the function body, name is used instead of nickname.
public String getTest3(@RequestParam(value = "nickname", required = false) String name) {
    System.out.println("nickname: " + name);
    return "getTest3";
}
```

@PathVaraible: 用来处理动态的URL,URL的值可以作为控制器中处理方法 的参数

@RequestBody: 接收的参数是来自requestBody中，即请求体。一般用于处理非 `Content-Type:application/x-www-form-urlencoded` 编码格式的数据， 比如：`application/json`, `application/xml`等类型的数据

```java
@RequestMapping(value = "/postTest4", method = RequestMethod.POST)
public String postTest4(@RequestBody User user) {
    System.out.println(user);
    return "postTest4";
}
```



# 3 静态资源访问 

- 静态资源一般放在 classpath/:static/目录  底下 
- 如果默认的静态资源过滤政策不能满足开发需求 , 也可以定义过滤的规则和静态资源的位置 
- 在application properties 中直接定义过滤规则和静态资源位置
```
//  过滤规则为`/static/**`,  
spring.mvc.static-path-pattern=/**   // 写成这样 通过 http://localhost:8080/dog.jpg 就可以直接访问 classpath:/static/ 下 的 dog.jpg

spring.web.resources.static-locations=classpath:/css/     //  就是加了个虚拟路径作为前缀. 写成这样 通过 http://localhost:8080/images/dog.jpg 就可以直接访问 classpath:/static/ 下 的 dog.jpg



// 静态资源位置为 classpath:/static/

spring.mvc.resources.static-location=classpath:/static/

// 如果自己 生成了个目录 css, 要让 springboot 访问这个 目录下的 东西 则要写下
spring.mvc.resources.static-location=classpath:/css/

```

classpath: 代表为类路径 , 为 target 这个目录 . 
在项目实际运行的时候, resource 下面的文件, 最终都会放到 target 这个目录下面去 , springboot 运行的也是 target 这个目录下的文件 
![](images/Pasted%20image%2020250220205513.png)

## 3.1 文件上传 

- 表单的enctype属性规定在发送到服务器之前应该如何对表单数据进行编码。
- 当表单的enctype="application/x-www-form-urlencoded"(默认)时， form表单中的数据格式为：key=value&key=value
- 当表单的enctype="multipart/form-data"时，其传输数据形式如下
    - ![](images/Pasted%20image%2020250220212521.png)


---


- Spring Boot工程嵌入的tomcat限制了请求的文件大小，每个文件的配置最大 为1Mb,单次请求的文件的总数不能大于10Mb。
- 更改这个默认值需要在配置文件（如application.properties)中加入两个配置


```
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB  // 每次请求所有文件的大小 
```


---


当表单的enctype="multipart/form-data"时，可以使用MultipartFile获取上传的文件数据，再通过transferTo方法将其写入到磁盘中

```java
package com.example.blog_system_1.controller;

import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;

@RestController
public class FileController {
    private static final String UPLOADED_FOLDER = System.getProperty("user.dir")+"/upload/";
    @PostMapping("/up")
    public String upload(String nickname, MultipartFile f) throws IOException {
        System.out.println("文件大小："+f.getSize());
        System.out.println(f.getContentType());
        System.out.println(f.getOriginalFilename());
        System.out.println(System.getProperty("user.dir"));
        saveFile(f);
        return "上传成功";
    }
    public void saveFile(MultipartFile f) throws IOException {
        File upDir =  new File( UPLOADED_FOLDER );

        if(!upDir.exists()) {
            upDir.mkdir();
        }

        File file = new File( UPLOADED_FOLDER + f.getOriginalFilename());
        f.transferTo(file);
    }
}
```


# 4 拦截器

拦截器在Wb系统中非常常见，对于某些全局统一的操作，我们可以把它提取 到拦截器中实现。总结起来，拦截器大致有以下几种使用场景：
- 权限检查：如登录检测，进入处理程序检测是否登录，如果没有，则直接返回 登录页面。
- 性能监控：有时系统在某段时间莫名其妙很慢，可以通过拦截器在进入处理程序之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间
- 通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有提取Locale、Theme信息等，只要是多个处理程序都需要的，即可使用拦截器实现。


## 4.1 拦截器定义 

Spring Boot定义了Handlerlnterceptor接口来实现自定义拦截器的功能
HandlerInterceptor接口定义了preHandle、postHandle、afterCompletion 三种方法，通过重写这三种方法实现请求前、请求后等操作
- preHandle 返回true, 就会继续调用后续的 preHandle.  如果返回为 false, 则会继续调用 后续的 preHandle 


![](images/Pasted%20image%2020250221110228.png)


![](images/Pasted%20image%2020250221105239.png)


```java
public class LoginInterceptor extends HandlerInterceptor{
    /**给0
    *在请求处理之前进行调用(Contro11er方法调用之前)
    */
    
    @override
    public boolean preHandle(HttpservletRequest request,HttpservletResponse response,object handler) throws Exception
    {
        if(条件){
            System.out.printin("通过")；
            return true;
        } else {
            System.out.printin("不通过")；
            return false;
        }
    }
    
}

```

## 4.2 拦截器注册 

- addPathPatterns方法定义拦截的地址
- excludePathPatterns定义排除某些地址不被拦截
- 添加的一个拦截器, 如果没有addPathPattern任何一个url, 侧默认拦截所有请求
- 如果没有excludePathPatterns任何一个请求，则默认不放过任何一个请求。

```java
@Configuration
public class Webconfigurer implements WebMvcConfigurer {
    @override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor()).addPathPatterns("/user/**");
    }
}
```



# 5 RESTful API 实现 

```java
@RestController
public class UserController{

    @GetMapping("/user/{id}")
    public String getUserById(@PathVariable int id){
        return"根据ID获取用户"；
    }
    
    @PostMapping("/user")
    public String save(User user){
        return"添加用户"；
    }
    
    @PutMapping("/user")
    public String update(User user){
        return"更新用户"；
    }
    
    @DeleteMapping("/user/{id}")
    public String deleteById(@PathVariable int id){
        return"根据ID删除用户"；
    }
}

```







